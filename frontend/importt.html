<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Add Product to Prisync</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: #222;
      color: #eee;
      margin: 20px;
    }
    h1, h2, p, label {
      margin: 5px 0;
    }
    button {
      padding: 10px 15px;
      margin: 5px;
      border: none;
      cursor: pointer;
      font-size: 14px;
      border-radius: 4px;
    }
    .button-primary {
      background-color: #4CAF50;
      color: #fff;
    }
    .button-secondary {
      background-color: #666;
      color: #fff;
    }
    /* Modal styling */
    #addProductModal {
      display: none; 
      position: fixed; 
      z-index: 9999; 
      left: 0; 
      top: 0; 
      width: 100%; 
      height: 100%; 
      overflow: auto; 
      background-color: rgba(0, 0, 0, 0.6); 
    }
    #addProductModalContent {
      background-color: #333;
      margin: 10% auto;
      padding: 20px;
      border-radius: 8px;
      width: 400px;
      max-width: 90%;
      box-shadow: 0 0 10px #000;
    }
    .modal-header {
      margin-bottom: 10px;
    }
    .form-row {
      display: flex;
      flex-direction: column;
      margin-bottom: 10px;
    }
    .form-row label {
      margin-bottom: 3px;
      font-weight: bold;
    }
    .form-row input {
      padding: 8px;
      border: 1px solid #555;
      border-radius: 4px;
      background-color: #444;
      color: #fff;
    }
    .button-row {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      margin-top: 20px;
    }
    /* Product card container */
    #productCardContainer {
      margin-top: 20px;
      display: none;
    }
    .product-card {
      background-color: #333;
      border: 1px solid #555;
      border-radius: 4px;
      padding: 15px;
      margin-bottom: 10px;
    }
    .product-card p {
      margin: 5px 0;
    }
    /* "Add URL" button in the card */
    .add-url-button {
      background-color: #222;
      color: #fff;
      border: 1px solid #555;
      margin: 10px 0 0 0;
    }
    /* Inline URL input styling */
    .url-input-container {
      display: none;
      margin-top: 10px;
    }
    .url-input-row {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
    }
    .url-input-row input {
      flex: 1;
      padding: 8px;
      border: 1px solid #555;
      border-radius: 4px;
      background-color: #444;
      color: #fff;
    }
    /* URL list styling with columns */
    .url-list {
      margin-top: 10px;
    }
    .url-list-header {
      display: grid;
      grid-template-columns: 2fr 1fr 1fr 1fr;
      gap: 10px;
      font-weight: bold;
      padding: 8px;
      background-color: #444;
      border-radius: 4px 4px 0 0;
      margin-bottom: 5px;
    }
    .url-item {
      display: grid;
      grid-template-columns: 2fr 1fr 1fr 1fr;
      gap: 10px;
      background-color: #444;
      padding: 8px;
      margin-top: 5px;
      border-radius: 4px;
      word-break: break-all;
    }
    .url-actions {
      display: flex;
      gap: 5px;
    }
    .url-actions button {
      padding: 2px 5px;
      font-size: 12px;
    }
    /* Pagination styling */
    .pagination {
      display: flex;
      justify-content: center;
      margin-top: 20px;
      gap: 10px;
    }
    .pagination button {
      background-color: #444;
      color: #fff;
      border: none;
      padding: 8px 12px;
      border-radius: 4px;
      cursor: pointer;
    }
    .pagination button.active {
      background-color: #4CAF50;
    }
    .pagination button:disabled {
      background-color: #333;
      color: #666;
      cursor: not-allowed;
    }
    .page {
      display: none;
    }
    .page.active {
      display: block;
    }
    .product-actions {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }
    
    .product-edit-form {
      background-color: #444;
      padding: 10px;
      border-radius: 4px;
      margin-bottom: 10px;
    }
    
    .product-edit-form .form-row {
      margin-bottom: 8px;
    }
    
    .product-edit-form .button-row {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      margin-top: 10px;
    }
    /* Add style for URL links */
    .url-item a {
      color: #4CAF50;
      text-decoration: none;
    }
    
    .url-item a:hover {
      text-decoration: underline;
    }
  </style>
</head>
<body>

  <!-- Add this at the very top of your content area (after any headers/nav but before the main content) -->
  <div id="productSearchContainer" style="width:100%; background-color:#f5f5f5; padding:15px 0; border-bottom:1px solid #ddd; margin-bottom:20px;">
    <div style="width:80%; max-width:600px; position:relative; margin:0 auto;">
      <input 
        type="text" 
        id="productSearchInput" 
        placeholder="Search products..." 
        style="width:100%; padding:10px; border-radius:4px; border:1px solid #ccc; font-size:16px;"
      >
      <button 
        id="clearSearchBtn" 
        style="position:absolute; right:10px; top:50%; transform:translateY(-50%); background:none; border:none; cursor:pointer; font-size:18px; color:#888; display:none;"
      >Ã—</button>
    </div>
  </div>

  <!-- Add this button next to your existing "Add Product" button -->
  <div style="display: flex; gap: 10px; margin-bottom: 20px;">
    <button class="button-primary" onclick="openAddProductModal()">Add Product</button>
    <button class="button-primary" onclick="exportProducts()">Export All Products</button>
  </div>

  <!-- Modal for adding a single product -->
  <div id="addProductModal">
    <div id="addProductModalContent">
      <div class="modal-header">
        <h2>Add Single Product</h2>
        <!-- Close button (X) -->
        <span style="position: absolute; top: 10px; right: 15px; font-size: 20px; cursor: pointer;" 
              onclick="closeAddProductModal()">&times;</span>
      </div>
      <div class="form-row">
        <label for="productName">Product Name</label>
        <input type="text" id="productName" placeholder="Enter product name">
      </div>
      <div class="form-row">
        <label for="productCode">Product Code</label>
        <input type="text" id="productCode" placeholder="Enter product code">
      </div>
      <div class="button-row">
        <button class="button-secondary" onclick="closeAddProductModal()">Cancel</button>
        <button class="button-primary" onclick="addProduct()">Add Product</button>
      </div>
    </div>
  </div>

  <!-- Container to display products as cards -->
  <div id="productCardContainer">
    <h2>Products</h2>
    <div id="productPages">
      <div class="page active" data-page="1">
        <div class="product-cards-page">
          <!-- Product cards will be inserted here dynamically -->
        </div>
      </div>
    </div>
    <div class="pagination" id="pagination" style="display: none !important;">
      <!-- This will be populated by the original code but will be invisible -->
    </div>
  </div>

  <!-- Our visible pagination UI -->
  <div id="simpleNumericPagination" style="display:flex; justify-content:center; margin:20px 0; flex-wrap:wrap; gap:5px;">
    <button id="simplePrevBtn" class="button-secondary">Previous</button>
    <div id="simplePageNumbers" style="display:flex; flex-wrap:wrap; gap:5px; align-items:center;">
      <!-- Page numbers will be inserted here -->
    </div>
    <button id="simpleNextBtn" class="button-secondary">Next</button>
  </div>

  <div class="container mt-4">
    <h1>Price Scraper</h1>
    
    <!-- Add Manual Update Button -->
    <div class="row mb-4">
        <div class="col">
            <button id="triggerUpdateBtn" class="btn btn-primary">
                <i class="fas fa-sync-alt"></i> Run Manual Price Update
            </button>
            <div id="updateStatus" class="mt-2"></div>
        </div>
    </div>
    
    <!-- Existing content -->

  <script>
    // Add this global flag at the top of your script
    let isEditingUrl = false;
    let isEditingProduct = false;

    // Open the modal and clear form
    function openAddProductModal() {
      console.log("Opening modal");
      document.getElementById('addProductModal').style.display = 'block';
      clearForm();
    }

    function closeAddProductModal() {
      console.log("Closing modal");
      document.getElementById('addProductModal').style.display = 'none';
    }

    function clearForm() {
      document.getElementById('productName').value = '';
      document.getElementById('productCode').value = '';
    }

    let productCount = 0;
    let currentPage = 1;
    const productsPerPage = 10;
    
    function addProduct() {
      console.log("addProduct function called");
      const productName = document.getElementById('productName').value.trim();
      const productCode = document.getElementById('productCode').value.trim();

      if (!productName && !productCode) {
        alert("Please enter at least Product Name or Product Code.");
        return;
      }
      
      // Only validate if a product code is provided
      if (productCode && productCode !== 'N/A') {
        // Check with the server if the product code already exists
        fetch('/api/products/validate-code', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ productCode })
        })
        .then(response => response.json())
        .then(result => {
          if (result.error) {
            alert(`Error: ${result.error}`);
          } else if (!result.valid) {
            alert(`Error: ${result.message}`);
          } else {
            // Product code is valid, proceed with adding the product
            addValidatedProduct(productName, productCode);
          }
        })
        .catch(err => {
          console.error("Error validating product code:", err);
          // If we can't check, we'll assume it's okay to proceed
          addValidatedProduct(productName, productCode);
        });
      } else {
        // No product code to validate, proceed with adding the product
        addValidatedProduct(productName, productCode);
      }
    }

    function addValidatedProduct(productName, productCode) {
      productCount++;
      const targetPage = Math.ceil(productCount / productsPerPage);
      if (targetPage > document.querySelectorAll('.page').length) {
        createNewPage(targetPage);
      }
      
      switchToPage(targetPage);
      const currentPageElement = document.querySelector(`.page[data-page="${targetPage}"] .product-cards-page`);
      addProductToPage(currentPageElement, productName, productCode);
    }
    
    function addProductToPage(pageElement, productName, productCode) {
      const newProductCard = document.createElement('div');
      newProductCard.className = 'product-card';
      newProductCard.innerHTML = `
        <div class="product-info">
          <p><strong>Product Name:</strong> ${productName || 'N/A'}</p>
          <p><strong>Product Code:</strong> ${productCode || 'N/A'}</p>
          <div class="product-actions">
            <button class="button-secondary" onclick="editProductInfo(this)">Edit Product</button>
            <button class="button-secondary" onclick="deleteProduct(this)">Delete Product</button>
          </div>
        </div>
        <div class="product-edit-form" style="display:none;">
          <div class="form-row">
            <label>Product Name</label>
            <input type="text" class="edit-product-name" value="${productName || ''}">
          </div>
          <div class="form-row">
            <label>Product Code</label>
            <input type="text" class="edit-product-code" value="${productCode || ''}">
          </div>
          <div class="button-row">
            <button class="button-primary" onclick="saveProductInfo(this)">Save</button>
            <button class="button-secondary" onclick="cancelProductEdit(this)">Cancel</button>
          </div>
        </div>
        <button class="add-url-button" onclick="toggleUrlInput(this)">Add URL</button>
        <div class="url-input-container">
          <div class="url-input-row">
            <input type="text" class="product-url" placeholder="Enter product URL">
            <button class="button-primary" onclick="saveUrl(this)">Save</button>
            <button class="button-secondary" onclick="toggleUrlInput(this)">Cancel</button>
          </div>
        </div>
        <div class="url-list">
          <div class="url-list-header">
            <div>Website</div>
            <div>Price</div>
            <div>Last Update</div>
            <div>Actions</div>
          </div>
        </div>
      `;
      pageElement.appendChild(newProductCard);
      document.getElementById('productCardContainer').style.display = 'block';
      closeAddProductModal();
      clearForm();
      autoSaveProducts();
    }
    
    function createNewPage(pageNumber) {
      const productPages = document.getElementById('productPages');
      if (document.querySelector(`.page[data-page="${pageNumber}"]`)) return;
      const newPage = document.createElement('div');
      newPage.className = 'page';
      newPage.dataset.page = pageNumber;
      newPage.innerHTML = `<div class="product-cards-page"></div>`;
      productPages.appendChild(newPage);
      
      const pagination = document.getElementById('pagination');
      const newButton = document.createElement('button');
      newButton.textContent = pageNumber;
      newButton.dataset.page = pageNumber;
      newButton.onclick = function() { switchToPage(pageNumber); };
      pagination.appendChild(newButton);
    }
    
    function switchToPage(pageNumber) {
      currentPage = pageNumber;
      document.querySelectorAll('.page').forEach(page => page.classList.remove('active'));
      document.querySelectorAll('.pagination button').forEach(button => button.classList.remove('active'));
      document.querySelector(`.page[data-page="${pageNumber}"]`).classList.add('active');
      document.querySelector(`.pagination button[data-page="${pageNumber}"]`).classList.add('active');
    }

    let currentEditingUrl = null;
    function toggleUrlInput(button) {
      const productCard = button.closest('.product-card');
      const container = productCard.querySelector('.url-input-container');
      const urlInput = productCard.querySelector('.product-url');
      
      if (container.style.display === 'block') {
        container.style.display = 'none';
        urlInput.value = '';
        if (currentEditingUrl) {
          const urlList = productCard.querySelector('.url-list');
          urlList.appendChild(currentEditingUrl);
          currentEditingUrl = null;
        }
        
        // Reset the URL input row to its original state with "Save" button
        const urlInputRow = productCard.querySelector('.url-input-row');
        urlInputRow.innerHTML = `
          <input type="text" class="product-url" placeholder="Enter product URL">
          <button class="button-primary" onclick="saveUrl(this)">Save</button>
          <button class="button-secondary" onclick="toggleUrlInput(this)">Cancel</button>
        `;
        
        isEditingUrl = false; // Clear the editing flag when done
      } else {
        // Reset the URL input row to ensure it has the correct buttons
        const urlInputRow = productCard.querySelector('.url-input-row');
        urlInputRow.innerHTML = `
          <input type="text" class="product-url" placeholder="Enter product URL">
          <button class="button-primary" onclick="saveUrl(this)">Save</button>
          <button class="button-secondary" onclick="toggleUrlInput(this)">Cancel</button>
        `;
        
        container.style.display = 'block';
        productCard.querySelector('.product-url').focus();
        isEditingUrl = true; // Mark that an edit is in progress
      }
    }
    
    async function saveUrl(button) {
      const productCard = button.closest('.product-card');
      const urlInput = productCard.querySelector('.product-url');
      const url = urlInput.value.trim();
      
      if (!url) {
        alert('Please enter a URL.');
        return;
      }
      
      let company = url;
      try {
        const urlObj = new URL(url);
        company = urlObj.hostname.replace('www.', '');
      } catch (e) {
        console.warn('Invalid URL format:', url);
      }
      
      const addButton = productCard.querySelector('.add-url-button');
      const originalText = addButton.textContent;
      addButton.textContent = 'Scraping...';
      addButton.disabled = true;
      
      let price = '-';
      let timestamp = new Date().toISOString();
      try {
        const response = await fetch('/scrape-price', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ url })
        });
        const result = await response.json();
        if (result.error) {
          console.error('Backend error:', result.error);
          alert(`Backend error: ${result.error}`);
        } else {
          price = result.price || '-';
          timestamp = result.timestamp || timestamp;
        }
      } catch (err) {
        console.error('Fetch error:', err);
        alert('Failed to fetch price from backend.');
      } finally {
        addButton.textContent = originalText;
        addButton.disabled = false;
      }
      
      const urlList = productCard.querySelector('.url-list');
      const urlItem = document.createElement('div');
      urlItem.className = 'url-item';
      urlItem.dataset.url = url;
      urlItem.dataset.timestamp = timestamp;
      urlItem.innerHTML = `
        <div><a href="${url}" target="_blank" rel="noopener noreferrer">${company}</a></div>
        <div>${price}</div>
        <div>${formatRelativeTime(timestamp)}</div>
        <div class="url-actions">
          <button class="button-secondary" onclick="editUrl(this)">Edit</button>
          <button class="button-secondary" onclick="deleteUrl(this)">Delete</button>
        </div>
      `;
      urlList.appendChild(urlItem);
      urlInput.value = '';
      toggleUrlInput(button);
      currentEditingUrl = null;
      autoSaveProducts();
      isEditingUrl = false; // Clear the editing flag when done
    }
    
    function editUrl(button) {
      const urlItem = button.closest('.url-item');
      const url = urlItem.dataset.url;
      const productCard = urlItem.closest('.product-card');
      const urlInputContainer = productCard.querySelector('.url-input-container');
      
      urlInputContainer.style.display = 'block';
      
      // Modify the URL input container to show only the Update button
      const urlInputRow = productCard.querySelector('.url-input-row');
      urlInputRow.innerHTML = `
        <input type="text" class="product-url" placeholder="Enter product URL" value="${url}">
        <button class="button-primary" onclick="updateUrl(this)">Update URL</button>
        <button class="button-secondary" onclick="toggleUrlInput(this)">Cancel</button>
      `;
      
      // Focus on the input after setting the HTML
      productCard.querySelector('.product-url').focus();
      
      currentEditingUrl = urlItem;
      isEditingUrl = true; // Mark that an edit is in progress
    }
    
    async function updateUrl(button) {
      const productCard = button.closest('.product-card');
      const urlInput = productCard.querySelector('.product-url');
      const url = urlInput.value.trim();
      const urlInputContainer = productCard.querySelector('.url-input-container');
      
      // Find the urlItem we're editing
      const urlItemToUpdate = currentEditingUrl;
      if (!urlItemToUpdate) {
        console.error('Could not find URL item to update');
        return;
      }
      
      if (!url) {
        alert('Please enter a URL.');
        return;
      }
      
      let company = url;
      try {
        const urlObj = new URL(url);
        company = urlObj.hostname.replace('www.', '');
      } catch (e) {
        console.warn('Invalid URL format:', url);
      }
      
      const originalText = button.textContent;
      button.textContent = 'Scraping...';
      button.disabled = true;
      
      let price = '-';
      let timestamp = new Date().toISOString();
      try {
        const response = await fetch('/scrape-price', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ url })
        });
        const result = await response.json();
        if (result.error) {
          console.error('Backend error:', result.error);
          alert(`Backend error: ${result.error}`);
        } else {
          price = result.price || '-';
          timestamp = result.timestamp || timestamp;
        }
      } catch (err) {
        console.error('Fetch error:', err);
        alert('Failed to fetch price from backend.');
      } finally {
        button.textContent = originalText;
        button.disabled = false;
      }
      
      urlItemToUpdate.dataset.url = url;
      urlItemToUpdate.dataset.timestamp = timestamp;
      urlItemToUpdate.innerHTML = `
        <div><a href="${url}" target="_blank" rel="noopener noreferrer">${company}</a></div>
        <div>${price}</div>
        <div>${formatRelativeTime(timestamp)}</div>
        <div class="url-actions">
          <button class="button-secondary" onclick="editUrl(this)">Edit</button>
          <button class="button-secondary" onclick="deleteUrl(this)">Delete</button>
        </div>
      `;
      
      // Reset the URL input row to its original state
      const urlInputRow = productCard.querySelector('.url-input-row');
      urlInputRow.innerHTML = `
        <input type="text" class="product-url" placeholder="Enter product URL">
        <button class="button-primary" onclick="saveUrl(this)">Save</button>
        <button class="button-secondary" onclick="toggleUrlInput(this)">Cancel</button>
      `;
      
      urlInput.value = '';
      urlInputContainer.style.display = 'none';
      currentEditingUrl = null;
      autoSaveProducts();
      isEditingUrl = false; // Clear the editing flag when done
    }
    
    function deleteUrl(button) {
      if (confirm('Are you sure you want to delete this URL?')) {
        const urlItem = button.closest('.url-item');
        urlItem.remove();
        autoSaveProducts();
      }
    }

    function renderProducts(products, activePage) {
      // Use provided activePage or fallback to the existing currentPage (default to 1)
      activePage = activePage || currentPage || 1;
      const container = document.getElementById('productCardContainer');
      container.style.display = 'block';
      document.getElementById('productPages').innerHTML = '';
      document.getElementById('pagination').innerHTML = '';

      productCount = products.length;
      const totalPages = Math.ceil(products.length / productsPerPage);
      // Ensure activePage is within valid bounds
      if (activePage > totalPages) activePage = totalPages;
      if (activePage < 1) activePage = 1;
      
      for (let page = 1; page <= totalPages; page++) {
        const pageDiv = document.createElement('div');
        pageDiv.className = 'page';
        pageDiv.dataset.page = page;
        if (page === activePage) pageDiv.classList.add('active');
        const cardsContainer = document.createElement('div');
        cardsContainer.className = 'product-cards-page';
        pageDiv.appendChild(cardsContainer);
        document.getElementById('productPages').appendChild(pageDiv);

        const pagBtn = document.createElement('button');
        pagBtn.textContent = page;
        pagBtn.dataset.page = page;
        pagBtn.onclick = function() { switchToPage(page); };
        if (page === activePage) pagBtn.classList.add('active');
        document.getElementById('pagination').appendChild(pagBtn);
      }
      
      products.forEach((product, index) => {
        const pageNumber = Math.floor(index / productsPerPage) + 1;
        const pageContainer = document.querySelector(`.page[data-page="${pageNumber}"] .product-cards-page`);
        const card = createProductCardFromData(product);
        pageContainer.appendChild(card);
      });
      
      // Update the global currentPage to the active page
      currentPage = activePage;
      
      // Force update timestamps after rendering
      setTimeout(updateAllTimestamps, 100);
    }

    function createProductCardFromData(product) {
      const card = document.createElement('div');
      card.className = 'product-card';
      card.innerHTML = `
        <div class="product-info">
          <p><strong>Product Name:</strong> ${product.productName || 'N/A'}</p>
          <p><strong>Product Code:</strong> ${product.productCode || 'N/A'}</p>
          <div class="product-actions">
            <button class="button-secondary" onclick="editProductInfo(this)">Edit Product</button>
            <button class="button-secondary" onclick="deleteProduct(this)">Delete Product</button>
          </div>
        </div>
        <div class="product-edit-form" style="display:none;">
          <div class="form-row">
            <label>Product Name</label>
            <input type="text" class="edit-product-name" value="${product.productName || ''}">
          </div>
          <div class="form-row">
            <label>Product Code</label>
            <input type="text" class="edit-product-code" value="${product.productCode || ''}">
          </div>
          <div class="button-row">
            <button class="button-primary" onclick="saveProductInfo(this)">Save</button>
            <button class="button-secondary" onclick="cancelProductEdit(this)">Cancel</button>
          </div>
        </div>
        <button class="add-url-button" onclick="toggleUrlInput(this)">Add URL</button>
        <div class="url-input-container">
          <div class="url-input-row">
            <input type="text" class="product-url" placeholder="Enter product URL">
            <button class="button-primary" onclick="saveUrl(this)">Save</button>
            <button class="button-secondary" onclick="toggleUrlInput(this)">Cancel</button>
          </div>
        </div>
        <div class="url-list">
          <div class="url-list-header">
            <div>Website</div>
            <div>Price</div>
            <div>Last Update</div>
            <div>Actions</div>
          </div>
        </div>
      `;
      const urlList = card.querySelector('.url-list');
      if (product.urls && Array.isArray(product.urls)) {
        product.urls.forEach(urlObj => {
          let company = urlObj.url;
          try {
            const urlObjTmp = new URL(urlObj.url);
            company = urlObjTmp.hostname.replace('www.', '');
          } catch (e) {}
          // Use lastUpdate if available, otherwise use timestamp
          const timestamp = urlObj.lastUpdate || urlObj.timestamp || new Date().toISOString();
          const urlItem = document.createElement('div');
          urlItem.className = 'url-item';
          urlItem.dataset.url = urlObj.url;
          urlItem.dataset.timestamp = timestamp;
          urlItem.innerHTML = `
            <div><a href="${urlObj.url}" target="_blank" rel="noopener noreferrer">${company}</a></div>
            <div>${urlObj.price || '-'}</div>
            <div data-timestamp="${timestamp}">${formatRelativeTime(timestamp)}</div>
            <div class="url-actions">
              <button class="button-secondary" onclick="editUrl(this)">Edit</button>
              <button class="button-secondary" onclick="deleteUrl(this)">Delete</button>
            </div>
          `;
          urlList.appendChild(urlItem);
        });
      }
      return card;
    }

    function autoSaveProducts() {
      const products = [];
      const productCards = document.querySelectorAll('.product-card');
      productCards.forEach(card => {
        const productNameText = card.querySelector('.product-info p:nth-child(1)').textContent;
        const productCodeText = card.querySelector('.product-info p:nth-child(2)').textContent;
        const productName = productNameText.split(':')[1].trim();
        const productCode = productCodeText.split(':')[1].trim();
        
        const urls = [];
        const urlItems = card.querySelectorAll('.url-item');
        urlItems.forEach(item => {
          urls.push({
            url: item.dataset.url,
            price: item.children[1].textContent,
            lastUpdate: item.dataset.timestamp
          });
        });
        
        products.push({
          productName,
          productCode,
          urls
        });
      });
      
      fetch('/api/products/auto-save', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(products)
      })
      .then(response => response.json())
      .then(result => {
        if (result.error) {
          console.error("Error auto-saving data:", result.error);
          localStorage.setItem('productDataBackup', JSON.stringify(products));
        } else {
          console.log("Data auto-saved successfully");
        }
      })
      .catch(err => {
        console.error("Error auto-saving data:", err);
        localStorage.setItem('productDataBackup', JSON.stringify(products));
      });
    }

    // New functions for editing product information
    function editProductInfo(button) {
      if (isEditingUrl) {
        alert('Please finish editing URL first.');
        return;
      }
      
      const productCard = button.closest('.product-card');
      const productInfo = productCard.querySelector('.product-info');
      const editForm = productCard.querySelector('.product-edit-form');
      
      // Get current values and set them in the edit form
      const productNameText = productInfo.querySelector('p:nth-child(1)').textContent;
      const productCodeText = productInfo.querySelector('p:nth-child(2)').textContent;
      const productName = productNameText.split(':')[1].trim();
      const productCode = productCodeText.split(':')[1].trim();
      
      productCard.querySelector('.edit-product-name').value = productName === 'N/A' ? '' : productName;
      productCard.querySelector('.edit-product-code').value = productCode === 'N/A' ? '' : productCode;
      
      // Toggle display
      productInfo.style.display = 'none';
      editForm.style.display = 'block';
      
      // Focus on first input
      productCard.querySelector('.edit-product-name').focus();
      
      isEditingProduct = true;
    }
    
    function saveProductInfo(button) {
      const productCard = button.closest('.product-card');
      const productInfo = productCard.querySelector('.product-info');
      const editForm = productCard.querySelector('.product-edit-form');
      
      const newName = productCard.querySelector('.edit-product-name').value.trim() || 'N/A';
      const newCode = productCard.querySelector('.edit-product-code').value.trim() || 'N/A';
      
      // Get current product code for comparison
      const currentCodeText = productInfo.querySelector('p:nth-child(2)').textContent;
      const currentCode = currentCodeText.split(':')[1].trim();
      
      // Only validate if code has changed and is not empty
      if (newCode !== currentCode && newCode !== 'N/A') {
        fetch('/api/products/validate-code', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ productCode: newCode })
        })
        .then(response => response.json())
        .then(result => {
          if (result.error) {
            alert(`Error: ${result.error}`);
          } else if (!result.valid) {
            alert(`Error: ${result.message}`);
          } else {
            // Product code is valid, proceed with saving
            updateProductInfo(productCard, productInfo, editForm, newName, newCode);
          }
        })
        .catch(err => {
          console.error("Error validating product code:", err);
          // If we can't check, we'll assume it's okay to proceed
          updateProductInfo(productCard, productInfo, editForm, newName, newCode);
        });
      } else {
        // No validation needed, proceed with saving
        updateProductInfo(productCard, productInfo, editForm, newName, newCode);
      }
    }
    
    function updateProductInfo(productCard, productInfo, editForm, newName, newCode) {
      // Update displayed info
      productInfo.querySelector('p:nth-child(1)').innerHTML = `<strong>Product Name:</strong> ${newName}`;
      productInfo.querySelector('p:nth-child(2)').innerHTML = `<strong>Product Code:</strong> ${newCode}`;
      
      // Toggle display
      productInfo.style.display = 'block';
      editForm.style.display = 'none';
      
      isEditingProduct = false;
      
      // Save changes
      autoSaveProducts();
    }
    
    function cancelProductEdit(button) {
      const productCard = button.closest('.product-card');
      const productInfo = productCard.querySelector('.product-info');
      const editForm = productCard.querySelector('.product-edit-form');
      
      // Toggle display without saving
      productInfo.style.display = 'block';
      editForm.style.display = 'none';
      
      isEditingProduct = false;
    }
    
    function deleteProduct(button) {
      if (isEditingUrl || isEditingProduct) {
        alert('Please finish editing first.');
        return;
      }
      
      if (confirm('Are you sure you want to delete this product and all its URLs?')) {
        const productCard = button.closest('.product-card');
        productCard.remove();
        
        // Update product count and pagination if needed
        productCount--;
        const totalPages = Math.max(1, Math.ceil(productCount / productsPerPage));
        
        // If current page is now empty and not the first page, go to previous page
        const currentPageElement = document.querySelector(`.page[data-page="${currentPage}"]`);
        if (currentPage > 1 && currentPageElement.querySelectorAll('.product-card').length === 0) {
          switchToPage(currentPage - 1);
        }
        
        // If the last page is now empty, remove it
        if (totalPages < document.querySelectorAll('.page').length) {
          const lastPage = document.querySelector(`.page[data-page="${document.querySelectorAll('.page').length}"]`);
          lastPage.remove();
          document.querySelector(`.pagination button[data-page="${document.querySelectorAll('.page').length + 1}"]`).remove();
        }
        
        // If no products left, hide container
        if (productCount === 0) {
          document.getElementById('productCardContainer').style.display = 'none';
        }
        
        // Save changes
        autoSaveProducts();
      }
    }

    // Add variables for countdown tracking
    let refreshCountdown = 300; // 5 minutes in seconds
    let countdownInterval;
    
    function updateCountdown() {
      const minutes = Math.floor(refreshCountdown / 60);
      const seconds = refreshCountdown % 60;
      console.log(`Next auto-refresh in: ${minutes}:${seconds < 10 ? '0' + seconds : seconds}`);
      refreshCountdown--;
      
      if (refreshCountdown < 0) {
        refreshCountdown = 300; // Reset to 5 minutes
      }
    }
    
    function loadSavedUrls() {
      // Skip refresh if user is currently editing
      if (isEditingUrl || isEditingProduct) {
        console.log("Editing in progress, skipping auto-refresh.");
        return;
      }
      
      console.log("Loading saved URLs...");
      // Reset countdown when refresh happens
      refreshCountdown = 300;
      console.log("Reset countdown timer to 5:00");
      
      fetch('/api/products')
      .then(response => response.json())
      .then(data => {
        if (data.error) throw new Error(data.error);
        console.log("Received data:", data);
        // Pass currentPage so that renderProducts keeps the same active page
        renderProducts(data, currentPage);
        localStorage.setItem('productDataBackup', JSON.stringify(data));
      })
      .catch(err => {
        console.error("Error loading data:", err);
        const backup = localStorage.getItem('productDataBackup');
        if (backup) {
          const data = JSON.parse(backup);
          renderProducts(data, currentPage);
          alert("Loaded data from local backup.");
        } else {
          alert("Failed to load product data.");
        }
      });
    }

    function updateAllTimestamps() {
      console.log("Updating all timestamps...");
      document.querySelectorAll('.url-item').forEach(item => {
        const timestamp = item.dataset.timestamp;
        if (timestamp) {
          const timeElement = item.children[2];
          const formattedTime = formatRelativeTime(timestamp);
          console.log(`Updating timestamp ${timestamp} to ${formattedTime}`);
          timeElement.textContent = formattedTime;
        }
      });
    }

    window.onload = function() {
      if (document.querySelectorAll('.page').length === 0) {
        createNewPage(1);
        switchToPage(1);
      }
      loadSavedUrls();
      
      // Log the initial value
      console.log("Starting auto-refresh countdown: 5:00");
      
      // Set up log to run every second
      countdownInterval = setInterval(updateCountdown, 1000);
      
      // Automatic refresh: reload product data every 5 minutes (300000ms)
      setInterval(loadSavedUrls, 300000);
      
      // Update relative timestamps every minute
      setInterval(updateAllTimestamps, 60000);
    };

    function formatRelativeTime(timestamp) {
      if (!timestamp) return '-';
      try {
        const now = new Date();
        const past = new Date(timestamp);
        if (isNaN(past.getTime())) return 'Unknown';
        const diffSec = Math.floor((now - past) / 1000);
        if (diffSec < 60) return 'Just now';
        const diffMin = Math.floor(diffSec / 60);
        if (diffMin < 60) return `${diffMin} minute${diffMin !== 1 ? 's' : ''} ago`;
        const diffHour = Math.floor(diffMin / 60);
        if (diffHour < 24) return `${diffHour} hour${diffHour !== 1 ? 's' : ''} ago`;
        const diffDay = Math.floor(diffHour / 24);
        if (diffDay < 30) return `${diffDay} day${diffDay !== 1 ? 's' : ''} ago`;
        const diffMonth = Math.floor(diffDay / 30);
        if (diffMonth < 12) return `${diffMonth} month${diffMonth !== 1 ? 's' : ''} ago`;
        const diffYear = Math.floor(diffMonth / 12);
        return `${diffYear} year${diffYear !== 1 ? 's' : ''} ago`;
      } catch (e) {
        console.error('Error formatting time:', e);
        return 'Unknown';
      }
    }

    window.onclick = function(event) {
      const modal = document.getElementById('addProductModal');
      if (event.target === modal) {
        closeAddProductModal();
      }
    };
    
    document.addEventListener('keydown', function(event) {
      if (event.key === 'Escape') {
        const modal = document.getElementById('addProductModal');
        if (modal.style.display === 'block') {
          closeAddProductModal();
        }
      }
    });

    // Initialize our own page tracking to ensure highlighting works
    let simpleCurrentPage = 1;
    
    // Fix page switching issues - simplified approach
    
    // Store the original switchToPage function first thing
    const originalSwitchToPage = window.switchToPage;
    
    // 1. Simplified page navigation that works with original code
    function goToPageAndHighlight(pageNum) {
      console.log("Going to page:", pageNum);
      
      // Update our tracked page number
      simpleCurrentPage = pageNum;
      
      // Call the original switchToPage directly (not our overridden version)
      if (typeof originalSwitchToPage === 'function') {
        originalSwitchToPage(pageNum);
      }
      
      // Update our pagination UI
      updateSimplePageNumbers();
      
      // Smooth scroll to top
      window.scrollTo({
        top: 0,
        behavior: 'smooth'
      });
    }
    
    // 2. Update page buttons to use this function
    function updateSimplePageNumbers() {
      // Get total pages
      const totalPages = document.querySelectorAll('.page').length || 1;
      
      // Update prev/next button states
      document.getElementById('simplePrevBtn').disabled = simpleCurrentPage <= 1;
      document.getElementById('simpleNextBtn').disabled = simpleCurrentPage >= totalPages;
      
      // Display range of page numbers
      const pageLimit = 10;
      let startPage = Math.max(1, simpleCurrentPage - Math.floor(pageLimit / 2));
      let endPage = Math.min(totalPages, startPage + pageLimit - 1);
      
      // Adjust range if needed
      if (endPage - startPage + 1 < pageLimit) {
        startPage = Math.max(1, endPage - pageLimit + 1);
      }
      
      // Clear and update the page numbers
      const pageNumbersContainer = document.getElementById('simplePageNumbers');
      pageNumbersContainer.innerHTML = '';
      
      // Create page number buttons
      for (let i = startPage; i <= endPage; i++) {
        const button = document.createElement('button');
        button.textContent = i;
        button.style.minWidth = '35px';
        button.style.padding = '5px';
        button.style.margin = '0 2px';
        
        // Highlight current page using our tracked variable
        if (i === simpleCurrentPage) {
          button.style.backgroundColor = '#4CAF50';
          button.style.color = 'white';
          button.style.fontWeight = 'bold';
        } else {
          button.style.backgroundColor = '#444';
        }
        
        // Direct click handler - use the original switchToPage
        button.addEventListener('click', function() {
          goToPageAndHighlight(i);
        });
        
        pageNumbersContainer.appendChild(button);
      }
      
      // Show pagination if multiple pages exist
      document.getElementById('simpleNumericPagination').style.display = 
        totalPages > 1 ? 'flex' : 'none';
    }
    
    // 3. Update Previous and Next button handlers
    function initSimplePagination() {
      // Set up Previous button
      document.getElementById('simplePrevBtn').addEventListener('click', function() {
        if (simpleCurrentPage > 1) {
          goToPageAndHighlight(simpleCurrentPage - 1);
        }
      });
      
      // Set up Next button
      document.getElementById('simpleNextBtn').addEventListener('click', function() {
        const totalPages = document.querySelectorAll('.page').length || 1;
        if (simpleCurrentPage < totalPages) {
          goToPageAndHighlight(simpleCurrentPage + 1);
        }
      });
      
      // Initial update
      updateSimplePageNumbers();
      
      // Hide original pagination
      const originalPagination = document.getElementById('pagination');
      if (originalPagination) {
        originalPagination.style.display = 'none';
      }
    }
    
    // 4. Monitor original page changes without breaking functionality
    // We'll use a less invasive approach that doesn't override switchToPage
    function monitorPageChanges() {
      // Check if the current page has changed
      const visiblePage = document.querySelector('.page[style*="display: block"]');
      if (visiblePage && visiblePage.id) {
        const pageMatch = visiblePage.id.match(/page-(\d+)/);
        if (pageMatch && pageMatch[1]) {
          const detectedPage = parseInt(pageMatch[1], 10);
          if (detectedPage !== simpleCurrentPage) {
            console.log("Page change detected:", detectedPage);
            simpleCurrentPage = detectedPage;
            updateSimplePageNumbers();
          }
        }
      }
    }
    
    // 5. Set up monitoring and initialization
    document.addEventListener('DOMContentLoaded', function() {
      setTimeout(function() {
        initSimplePagination();
        
        // Check for page changes periodically
        setInterval(monitorPageChanges, 300);
      }, 1000);
    });
    
    // 6. Reorganize pages without breaking navigation
    function reorganizePages() {
      console.log("Reorganizing pages...");
      
      // ...reorganization logic...
      
      // After reorganization, make sure we're on a valid page
      const totalPages = document.querySelectorAll('.page').length || 1;
      if (simpleCurrentPage > totalPages) {
        simpleCurrentPage = totalPages;
        if (typeof originalSwitchToPage === 'function') {
          originalSwitchToPage(simpleCurrentPage);
        }
      }
      
      updateSimplePageNumbers();
    }

    // Product search functionality
    document.addEventListener('DOMContentLoaded', function() {
      const searchInput = document.getElementById('productSearchInput');
      const clearBtn = document.getElementById('clearSearchBtn');
      
      if (!searchInput || !clearBtn) return;
      
      // Show/hide clear button based on input
      searchInput.addEventListener('input', function() {
        clearBtn.style.display = this.value ? 'block' : 'none';
        performSearch(this.value);
      });
      
      // Clear search when button is clicked
      clearBtn.addEventListener('click', function() {
        searchInput.value = '';
        clearBtn.style.display = 'none';
        resetSearch();
      });
      
      // Handle Enter key
      searchInput.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') {
          performSearch(this.value);
        } else if (e.key === 'Escape') {
          searchInput.value = '';
          clearBtn.style.display = 'none';
          resetSearch();
        }
      });
      
      // Updated search function to target both Product Code and Product Name
      function performSearch(query) {
        query = query.toLowerCase().trim();
        
        // Get all product cards across all pages
        const allProductCards = document.querySelectorAll('.product-card');
        let matchCount = 0;
        
        // If no query, reset search
        if (!query) {
          resetSearch();
          return;
        }
        
        // Create or get "no results" message element
        let noResultsElem = document.getElementById('noSearchResults');
        if (!noResultsElem) {
          noResultsElem = document.createElement('div');
          noResultsElem.id = 'noSearchResults';
          noResultsElem.style.textAlign = 'center';
          noResultsElem.style.padding = '20px';
          noResultsElem.style.color = '#666';
          noResultsElem.style.fontStyle = 'italic';
          noResultsElem.style.display = 'none';
          noResultsElem.textContent = 'No products found matching your search.';
          
          // Insert after search bar
          const searchContainer = document.getElementById('productSearchContainer');
          if (searchContainer && searchContainer.parentNode) {
            searchContainer.parentNode.insertBefore(noResultsElem, searchContainer.nextSibling);
          }
        }
        
        // Search through all product cards
        allProductCards.forEach(card => {
          // Look for product name and product code in the specific formats
          let productName = '';
          let productCode = '';
          
          const paragraphs = card.querySelectorAll('p');
          for (let p of paragraphs) {
            // Look for Product Name
            if (p.innerHTML.includes('<strong>Product Name:</strong>')) {
              productName = p.textContent.replace('Product Name:', '').trim();
            }
            
            // Look for Product Code
            if (p.innerHTML.includes('<strong>Product Code:</strong>')) {
              productCode = p.textContent.replace('Product Code:', '').trim();
            }
          }
          
          // Combine searchable text
          let searchText = (productName + ' ' + productCode).toLowerCase();
          
          // Check if product matches search
          const matches = searchText.includes(query);
          
          // Show/hide based on match
          card.style.display = matches ? '' : 'none';
          
          if (matches) matchCount++;
        });
        
        // Show/hide "no results" message
        noResultsElem.style.display = matchCount === 0 ? 'block' : 'none';
        
        // Make all pages visible when searching
        const pages = document.querySelectorAll('.page');
        pages.forEach(page => {
          page.style.display = 'block';
        });
        
        // Hide pagination when searching
        const paginationElem = document.getElementById('simpleNumericPagination');
        if (paginationElem) {
          paginationElem.style.display = 'none';
        }
      }
      
      // Reset search function
      function resetSearch() {
        // Show all products
        const allProductCards = document.querySelectorAll('.product-card');
        allProductCards.forEach(card => {
          card.style.display = '';
        });
        
        // Hide "no results" message
        const noResultsElem = document.getElementById('noSearchResults');
        if (noResultsElem) {
          noResultsElem.style.display = 'none';
        }
        
        // Restore pagination visibility
        const paginationElem = document.getElementById('simpleNumericPagination');
        if (paginationElem) {
          paginationElem.style.display = 'flex';
        }
        
        // Reset page visibility
        const pages = document.querySelectorAll('.page');
        pages.forEach((page, index) => {
          page.style.display = index + 1 === simpleCurrentPage ? 'block' : 'none';
        });
      }
    });

    function exportProducts() {
      console.log("Exporting products...");
      
      // Store a reference to the button that was clicked
      const exportButton = event.target;
      const originalText = exportButton.textContent;
      
      // Show loading state
      exportButton.textContent = "Preparing Export...";
      exportButton.disabled = true;
      
      // Create and trigger download
      fetch('/api/export')
        .then(response => {
          if (!response.ok) {
            return response.json().then(data => {
              throw new Error(data.error || 'Export failed');
            });
          }
          return response.blob();
        })
        .then(blob => {
          // Create download link
          const url = window.URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.style.display = 'none';
          a.href = url;
          
          // Set filename
          const filename = `product_export_${new Date().toISOString().slice(0,10)}.csv`;
          a.download = filename;
          
          // Trigger download
          document.body.appendChild(a);
          a.click();
          
          // Clean up
          window.URL.revokeObjectURL(url);
          document.body.removeChild(a);
          
          // Important: Reset button text and state immediately after successful download
          exportButton.textContent = originalText;
          exportButton.disabled = false;
        })
        .catch(error => {
          console.error('Export error:', error);
          alert('Failed to export products: ' + error.message);
          
          // Also reset button in case of error
          exportButton.textContent = originalText;
          exportButton.disabled = false;
        });
    }

    // Add manual update functionality
    document.getElementById('triggerUpdateBtn').addEventListener('click', async function() {
        const button = this;
        const statusDiv = document.getElementById('updateStatus');
        
        // Disable button and show loading state
        button.disabled = true;
        button.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Running Update...';
        statusDiv.innerHTML = '<div class="alert alert-info">Starting manual price update...<br>This may take a few minutes.</div>';
        
        try {
            const response = await fetch('/api/trigger-update', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            
            const data = await response.json();
            
            if (data.success) {
                statusDiv.innerHTML = `
                    <div class="alert alert-success">
                        <strong>Update Completed!</strong><br>
                        Started: ${new Date(data.start_time).toLocaleString()}<br>
                        Completed: ${new Date(data.end_time).toLocaleString()}<br>
                        Products Updated: ${data.updated_count}<br>
                        Errors: ${data.error_count}<br>
                        Dropbox Status: ${data.dropbox_status}
                    </div>
                `;
                
                // Refresh the product list to show new prices
                loadSavedUrls();
            } else {
                statusDiv.innerHTML = `
                    <div class="alert alert-danger">
                        <strong>Update Failed:</strong> ${data.error}
                    </div>
                `;
            }
        } catch (error) {
            statusDiv.innerHTML = `
                <div class="alert alert-danger">
                    <strong>Error:</strong> ${error.message}<br>
                    The update may have partially completed. Please check the product list for any updates.
                </div>
            `;
        } finally {
            // Re-enable button
            button.disabled = false;
            button.innerHTML = '<i class="fas fa-sync-alt"></i> Run Manual Price Update';
        }
    });
  </script>
</body>
</html>